name: å¤šè¿›ç¨‹æ›´æ–°jn950

on:
  workflow_dispatch:  # æ‰‹åŠ¨è§¦å‘
  schedule:
  # åŒ—äº¬æ—¶é—´å‡Œæ™¨2ç‚¹ = UTCæ—¶é—´å‰ä¸€å¤©18ç‚¹
  - cron: '0 2,10 * * *'

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests aiohttp aiodns
        
    - name: Process TV Channels (Multithreaded)
      run: |
        cat <<'EOF'>tv_processor.py
        import re
        import requests
        from urllib.parse import quote
        import sys
        import asyncio
        import aiohttp
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import time

        # ==================== é…ç½®å‚æ•° ====================
        SOURCE_URL = "https://raw.githubusercontent.com/jn950/live/refs/heads/main/tv/pllive.txt"
        LOGO_BASE_URL = "https://gitee.com/tyrian9905/iptv/raw/master/tvlogo/"
        EPG_URL = "https://gitee.com/taksssss/tv/raw/main/epg/51zmt.xml.gz"
        GROUP_FLAT = "JN950"
        MAX_WORKERS = 20  # æœ€å¤§å¹¶å‘çº¿ç¨‹æ•°
        REQUEST_TIMEOUT = 3  # è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
        BATCH_SIZE = 50  # æ¯æ‰¹å¤„ç†çš„é“¾æ¥æ•°é‡

        # ==================== CCTVæ˜¾ç¤ºåç§°æ˜ å°„ ====================
        CCTV_DISPLAY_NAMES = {
            "CCTV1": "CCTV-1 ç»¼åˆ",
            "CCTV2": "CCTV-2 è´¢ç»",
            "CCTV3": "CCTV-3 ç»¼è‰º",
            "CCTV4": "CCTV-4 ä¸­æ–‡å›½é™…",
            "CCTV5": "CCTV-5 ä½“è‚²",
            "CCTV6": "CCTV-6 ç”µå½±",
            "CCTV7": "CCTV-7 å›½é˜²å†›äº‹",
            "CCTV8": "CCTV-8 ç”µè§†å‰§",
            "CCTV9": "CCTV-9 çºªå½•",
            "CCTV11": "CCTV-11 æˆæ›²",
            "CCTV12": "CCTV-12 ç¤¾ä¼šä¸æ³•",
            "CCTV13": "CCTV-13 æ–°é—»",
            "CCTV14": "CCTV-14 å°‘å„¿",
            "CCTV15": "CCTV-15 éŸ³ä¹",
            "CCTV16": "CCTV-16 å¥¥æ—åŒ¹å…‹",
            "CCTV17": "CCTV-17 å†œä¸šå†œæ‘"
        }

        class ChannelProcessor:
            """é¢‘é“å¤„ç†å™¨ç±»ï¼ŒåŒ…å«æ‰€æœ‰å¤„ç†é€»è¾‘"""
            
            def __init__(self):
                self.valid_channels = []
                self.skipped_channels = []
                self.start_time = time.time()
                
            def check_source_content(self, content):
                """æ£€æŸ¥æºå†…å®¹æ˜¯å¦åŒ…å«è¶³å¤Ÿçš„IP:ç«¯å£æ ¼å¼"""
                ip_port_pattern = r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\:\d+'
                matches = re.findall(ip_port_pattern, content)
                
                match_count = len(matches)
                print(f"åœ¨æºå†…å®¹ä¸­æ‰¾åˆ° {match_count} ä¸ªIP:ç«¯å£æ ¼å¼çš„åŒ¹é…")
                
                if match_count < 10:
                    print(f"âŒ åŒ¹é…åˆ°çš„IP:ç«¯å£æ ¼å¼å°‘äº10ä¸ª({match_count})ï¼Œç»“æŸå¤„ç†")
                    return False
                else:
                    print(f"âœ… åŒ¹é…åˆ°çš„IP:ç«¯å£æ ¼å¼è¶³å¤Ÿ({match_count}ä¸ª)ï¼Œå¼€å§‹å¤„ç†")
                    return True
            
            def normalize_tvname(self, tvname):
                """æ­¥éª¤80: æ ‡å‡†åŒ–tvname"""
                tvname = tvname.upper()
                characters_to_remove = [' ', '-', 'FHD', 'HD', 'SD', 'é«˜æ¸…', 'æ ‡æ¸…', 'è¶…æ¸…']
                for char in characters_to_remove:
                    tvname = tvname.replace(char, '')
                return tvname
            
            def process_special_channels(self, tvname):
                """æ­¥éª¤100.1-100.3: å¤„ç†ç‰¹æ®Šé¢‘é“åç§°"""
                # æ­¥éª¤100.1: è¥¿è—å«è§†è—è¯­
                if "è¥¿è—å«è§†è—è¯­" in tvname:
                    return "è—è¯­å«è§†", "è—è¯­å«è§†"
                
                # æ­¥éª¤100.2: ç¬¬ä¸€è´¢ç»
                if tvname == "ç¬¬ä¸€è´¢ç»":
                    return "ä¸œæ–¹è´¢ç»", "ä¸œæ–¹è´¢ç»"
                
                # æ­¥éª¤100.3: ä¸­å›½äº¤é€šé¢‘é“
                if tvname == "ä¸­å›½äº¤é€šé¢‘é“":
                    return "ä¸­å›½äº¤é€š", "ä¸­å›½äº¤é€š"
                
                return tvname, tvname
            
            def process_cgtn_channels(self, tvname):
                """æ­¥éª¤100.5: å¤„ç†CGTNé¢‘é“"""
                # æ­¥éª¤100.5.1: CGTNè‹±è¯­
                if "CGTNè‹±è¯­" in tvname:
                    return "CGTN", "CGTN"
                
                # æ­¥éª¤100.5.2: é˜¿æ‹‰ä¼¯è¯­
                if "é˜¿æ‹‰ä¼¯è¯­" in tvname:
                    return "CGTNé˜¿è¯­", "CGTNé˜¿æ‹‰ä¼¯è¯­"
                
                # æ­¥éª¤100.5.3: è¥¿ç­ç‰™è¯­
                if "è¥¿ç­ç‰™è¯­" in tvname:
                    return "CGTNè¥¿è¯­", "CGTNè¥¿ç­ç‰™è¯­"
                
                return tvname, tvname
            
            def process_cctv_channels(self, tvname):
                """æ­¥éª¤100.7: å¤„ç†CCTVé¢‘é“"""
                # æ­¥éª¤100.7.1: 3Dé¢‘é“
                if "3D" in tvname:
                    return "CCTV3D", "CCTV 3D"
                
                # æ­¥éª¤100.7.2: ç¾æ´²é¢‘é“
                if "ç¾æ´²" in tvname or "AME" in tvname:
                    return "CCTV4ç¾æ´²", "CCTV-4 ç¾æ´²"
                
                # æ­¥éª¤100.7.3: æ¬§æ´²é¢‘é“
                if "æ¬§æ´²" in tvname or "EUO" in tvname:
                    return "CCTV4æ¬§æ´²", "CCTV-4 æ¬§æ´²"
                
                # æ­¥éª¤100.7.4: 5+é¢‘é“
                if "+" in tvname or "PLUS" in tvname:
                    return "CCTV5+", "CCTV-5+ ä½“è‚²èµ›äº‹"
                
                # æ­¥éª¤100.7.5: CCTV10
                if "10" in tvname:
                    return "CCTV10", "CCTV-10 ç§‘æ•™"
                
                # æ­¥éª¤100.7.6: å…¶ä»–CCTVæ•°å­—é¢‘é“
                modified_name = tvname.replace("0", "") + "HD"
                pattern = r"(CCTV\d{1,2})[^\d]"
                match = re.search(pattern, modified_name)
                
                if match:
                    cctv_num = match.group(1)
                    display_name = CCTV_DISPLAY_NAMES.get(cctv_num, cctv_num)
                    return cctv_num, display_name
                
                return tvname, tvname
            
            def build_logo_url(self, tvname):
                """æ„å»ºlogo URL"""
                safe_tvname = quote(tvname.replace("/", ""))
                return f"{LOGO_BASE_URL}{safe_tvname}.png"
            
            async def check_url_async(self, session, url, channel_name):
                """å¼‚æ­¥æ£€æŸ¥URLå¯ç”¨æ€§"""
                try:
                    async with session.head(url, timeout=aiohttp.ClientTimeout(total=REQUEST_TIMEOUT),
                                            allow_redirects=True) as response:
                        status_code = response.status
                        return status_code in [200, 301, 302], channel_name, url, status_code
                except Exception as e:
                    return False, channel_name, url, str(e)
            
            async def batch_check_urls(self, urls_info):
                """æ‰¹é‡å¼‚æ­¥æ£€æŸ¥URL"""
                connector = aiohttp.TCPConnector(limit_per_host=10, limit=MAX_WORKERS)
                async with aiohttp.ClientSession(connector=connector) as session:
                    tasks = []
                    for channel_name, url in urls_info:
                        task = asyncio.create_task(self.check_url_async(session, url, channel_name))
                        tasks.append(task)
                    
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    
                    valid_results = []
                    for result in results:
                        if isinstance(result, Exception):
                            continue
                        is_valid, channel_name, url, info = result
                        if is_valid:
                            valid_results.append((channel_name, url))
                        else:
                            self.skipped_channels.append((channel_name, url, f"é“¾æ¥æ£€æŸ¥å¤±è´¥: {info}"))
                    
                    return valid_results
            
            def process_line(self, line, current_group_orig, current_group_cat):
                """å¤„ç†å•è¡Œæ•°æ®ï¼Œä¸è¿›è¡ŒURLæ£€æŸ¥"""
                # æ­¥éª¤40: è·³è¿‡ç©ºç™½è¡Œ
                line = line.strip()
                if not line:
                    return current_group_orig, current_group_cat, None
                
                # æ­¥éª¤50: åˆ†å‰²è¡Œå†…å®¹
                parts = line.split(',', 1)
                if len(parts) < 2:
                    return current_group_orig, current_group_cat, None
                
                str1, str2 = parts[0].strip(), parts[1].strip()
                
                # æ­¥éª¤60: å¤„ç†str2çš„ä¸åŒæƒ…å†µ
                if not str2:
                    return current_group_orig, current_group_cat, None
                elif str2 == "#genre#":
                    return str1, current_group_cat, None
                else:
                    tvname = str1
                    tvlink = str2
                    
                    # æ­¥éª¤70: è·³è¿‡4K/8Ké¢‘é“å’Œç‰¹å®šå«è§†é¢‘é“
                    if "4K" in tvname or "8K" in tvname or re.search(r"å«è§†[\d]", tvname):
                        return current_group_orig, current_group_cat, None
                    
                    # æ­¥éª¤80: æ ‡å‡†åŒ–tvname
                    tvname = self.normalize_tvname(tvname)
                    
                    # æ­¥éª¤90: display_nameåˆå§‹åŒ–ä¸ºtvname
                    display_name = tvname
                    
                    # æ­¥éª¤100: æ ¹æ®tvnameå¤„ç†
                    final_group_cat = current_group_cat
                    final_tvname = tvname
                    final_display_name = display_name
                    
                    # æ­¥éª¤100.1-100.3: å¤„ç†ç‰¹æ®Šé¢‘é“
                    final_tvname, final_display_name = self.process_special_channels(final_tvname)
                    
                    # æ­¥éª¤100.5: å¤„ç†CETV/CGTN
                    if "CETV" in final_tvname or "CGTN" in final_tvname:
                        final_group_cat = "å¤®è§†"
                        final_tvname, final_display_name = self.process_cgtn_channels(final_tvname)
                    
                    # æ­¥éª¤100.7: å¤„ç†CCTVé¢‘é“
                    elif "CCTV" in final_tvname:
                        final_group_cat = "å¤®è§†"
                        final_tvname, final_display_name = self.process_cctv_channels(final_tvname)
                    
                    # æ„å»ºlogo URL
                    logo_url = self.build_logo_url(final_tvname)
                    
                    return current_group_orig, current_group_cat, {
                        'tvname': final_tvname,
                        'display_name': final_display_name,
                        'tvlink': tvlink,
                        'group_orig': current_group_orig,
                        'group_cat': final_group_cat,
                        'group_flat': GROUP_FLAT,
                        'logo_url': logo_url,
                        'original_name': str1  # ä¿å­˜åŸå§‹åç§°ç”¨äºæ£€æŸ¥
                    }
            
            def write_channel_entry(self, file_obj, tvname, group_name, display_name, url, logo_url):
                """å†™å…¥M3Ué¢‘é“æ¡ç›®"""
                entry = f'#EXTINF:-1 tvg-name="{tvname}" '
                entry += f'tvg-logo="{logo_url}" '
                entry += f'group-title="{group_name}",{display_name}\n'
                entry += f"{url}\n"
                file_obj.write(entry)
            
            def write_m3u_files(self, valid_channels):
                """å†™å…¥M3Uæ–‡ä»¶"""
                with (
                    open('JN950åŸç‰ˆ.m3u', 'w', encoding='utf-8') as f_orig,
                    open('JN950åˆ†èŠ‚ç›®.m3u', 'w', encoding='utf-8') as f_cat,
                    open('JN950æ— åˆ†ç»„.m3u', 'w', encoding='utf-8') as f_flat
                ):
                    # å†™å…¥æ–‡ä»¶å¤´
                    m3u_header = f'#EXTM3U x-tvg-url="{EPG_URL}"\n'
                    f_orig.write(m3u_header)
                    f_cat.write(m3u_header)
                    f_flat.write(m3u_header)
                    
                    # å†™å…¥é¢‘é“æ¡ç›®
                    for channel_data in valid_channels:
                        # æ­¥éª¤110: å†™å…¥åŸç‰ˆæ–‡ä»¶
                        self.write_channel_entry(
                            f_orig,
                            channel_data['tvname'],
                            channel_data['group_orig'],
                            channel_data['display_name'],
                            channel_data['tvlink'],
                            channel_data['logo_url']
                        )
                        
                        # æ­¥éª¤120: å†™å…¥åˆ†ç±»ç‰ˆ
                        self.write_channel_entry(
                            f_cat,
                            channel_data['tvname'],
                            channel_data['group_cat'],
                            channel_data['display_name'],
                            channel_data['tvlink'],
                            channel_data['logo_url']
                        )
                        
                        # æ­¥éª¤130: å†™å…¥æ— åˆ†ç»„ç‰ˆ
                        self.write_channel_entry(
                            f_flat,
                            channel_data['tvname'],
                            channel_data['group_flat'],
                            channel_data['display_name'],
                            channel_data['tvlink'],
                            channel_data['logo_url']
                        )
            
            def print_statistics(self):
                """æ‰“å°ç»Ÿè®¡ä¿¡æ¯"""
                elapsed_time = time.time() - self.start_time
                print("\n" + "="*50)
                print("ğŸ“Š å¤„ç†ç»Ÿè®¡ä¿¡æ¯:")
                print(f"  æœ‰æ•ˆé¢‘é“æ•°: {len(self.valid_channels)}")
                print(f"  è·³è¿‡çš„é¢‘é“æ•°: {len(self.skipped_channels)}")
                print(f"  æ€»å¤„ç†æ—¶é—´: {elapsed_time:.2f}ç§’")
                print(f"  å¹³å‡æ¯ä¸ªé¢‘é“å¤„ç†æ—¶é—´: {elapsed_time/max(len(self.valid_channels), 1):.3f}ç§’")
                
                if self.skipped_channels:
                    print("\nğŸ“‹ è·³è¿‡çš„é¢‘é“åŸå› :")
                    skip_reasons = {}
                    for _, _, reason in self.skipped_channels[:10]:  # åªæ˜¾ç¤ºå‰10ä¸ª
                        if reason in skip_reasons:
                            skip_reasons[reason] += 1
                        else:
                            skip_reasons[reason] = 1
                    
                    for reason, count in skip_reasons.items():
                        print(f"  {reason}: {count}ä¸ªé¢‘é“")
                    
                    if len(self.skipped_channels) > 10:
                        print(f"  ... ä»¥åŠå…¶ä»– {len(self.skipped_channels) - 10} ä¸ªé¢‘é“")
                print("="*50 + "\n")
            
            async def process_channels_async(self):
                """å¼‚æ­¥å¤„ç†é¢‘é“çš„ä¸»å‡½æ•°"""
                try:
                    # æ­¥éª¤20: è·å–èŠ‚ç›®æºå†…å®¹
                    print("æ­£åœ¨è·å–æºå†…å®¹...")
                    response = requests.get(SOURCE_URL, timeout=10)
                    source_content = response.text
                    
                    # æ£€æŸ¥æºå†…å®¹
                    if not self.check_source_content(source_content):
                        print("âŒ æºå†…å®¹ä¸ç¬¦åˆè¦æ±‚ï¼Œç»“æŸè„šæœ¬è¿è¡Œ")
                        return False
                    
                    # æ­¥éª¤30: åˆå§‹åŒ–å˜é‡
                    group_orig = ""
                    group_cat = "å«è§†"
                    
                    all_lines = source_content.splitlines()
                    
                    print(f"å‡†å¤‡å¤„ç† {len(all_lines[2:])} ä¸ªåŸå§‹æ¡ç›®...")
                    
                    # ç¬¬ä¸€éï¼šè§£ææ‰€æœ‰é¢‘é“ï¼Œä¸æ£€æŸ¥é“¾æ¥
                    all_parsed_channels = []
                    urls_to_check = []  # éœ€è¦æ£€æŸ¥çš„URLåˆ—è¡¨
                    
                    for line in all_lines[2:]:
                        result = self.process_line(line, group_orig, group_cat)
                        group_orig, group_cat, channel_data = result
                        
                        if channel_data is not None:
                            all_parsed_channels.append(channel_data)
                            urls_to_check.append((channel_data['original_name'], channel_data['tvlink']))
                    
                    print(f"è§£æå‡º {len(all_parsed_channels)} ä¸ªé¢‘é“ï¼Œå¼€å§‹å¹¶è¡Œæ£€æŸ¥é“¾æ¥...")
                    
                    # æ‰¹é‡æ£€æŸ¥URL
                    valid_urls_set = set()
                    
                    # åˆ†æ‰¹å¤„ç†URLï¼Œé¿å…ä¸€æ¬¡å¤„ç†å¤ªå¤š
                    for i in range(0, len(urls_to_check), BATCH_SIZE):
                        batch = urls_to_check[i:i+BATCH_SIZE]
                        print(f"æ£€æŸ¥é“¾æ¥æ‰¹æ¬¡ {i//BATCH_SIZE + 1}/{(len(urls_to_check) + BATCH_SIZE - 1)//BATCH_SIZE} ({len(batch)}ä¸ª)")
                        
                        valid_batch_urls = await self.batch_check_urls(batch)
                        
                        for channel_name, url in valid_batch_urls:
                            valid_urls_set.add(url)
                        
                        # æ˜¾ç¤ºè¿›åº¦
                        progress = min((i + len(batch)) / len(urls_to_check) * 100, 100)
                        print(f"  è¿›åº¦: {progress:.1f}% ({i + len(batch)}/{len(urls_to_check)})")
                    
                    print(f"é“¾æ¥æ£€æŸ¥å®Œæˆï¼Œæœ‰æ•ˆé“¾æ¥: {len(valid_urls_set)} ä¸ª")
                    
                    # ç¬¬äºŒéï¼šç­›é€‰æœ‰æ•ˆé¢‘é“
                    for channel_data in all_parsed_channels:
                        if channel_data['tvlink'] in valid_urls_set:
                            self.valid_channels.append(channel_data)
                        else:
                            self.skipped_channels.append((channel_data['tvname'], channel_data['tvlink'], "é“¾æ¥ä¸å¯ç”¨"))
                    
                    # å†™å…¥æ–‡ä»¶
                    if self.valid_channels:
                        self.write_m3u_files(self.valid_channels)
                        print(f"âœ… å¤„ç†å®Œæˆï¼Œå·²ç”Ÿæˆ {len(self.valid_channels)} ä¸ªé¢‘é“çš„M3Uæ–‡ä»¶")
                        self.print_statistics()
                        return True
                    else:
                        print("âŒ æ²¡æœ‰æœ‰æ•ˆçš„é¢‘é“é“¾æ¥ï¼Œç»“æŸå¤„ç†")
                        return False
                        
                except Exception as e:
                    print(f"âŒ å¤„ç†è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
                    import traceback
                    traceback.print_exc()
                    return False

        def main():
            """ä¸»å¤„ç†å‡½æ•°"""
            processor = ChannelProcessor()
            
            # è¿è¡Œå¼‚æ­¥å¤„ç†
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            try:
                success = loop.run_until_complete(processor.process_channels_async())
                if not success:
                    sys.exit(1)
            finally:
                loop.close()

        if __name__ == "__main__":
            main()
        EOF
        
        python tv_processor.py
      
    - name: å¼€å§‹æ¨é€
      if: success()  # åªæœ‰å‰é¢çš„æ­¥éª¤éƒ½æˆåŠŸæ‰æ‰§è¡Œæ¨é€
      run: |
        # é…ç½®Git
        git config --global user.name "Auto Sync"
        git config --global user.email "auto@sync.com"
        USER="tyrian9905"
        REPO="iptv"
        
        # è·å–åŒ—äº¬æ—¶é—´
        export TZ='Asia/Shanghai'
        BEIJING_TIME=$(date '+%Y-%m-%d %H:%M:%S')
        
        # å…‹éš†ä»“åº“
        git clone https://oauth2:${{ secrets.GITEE_TOKEN }}@gitee.com/${USER}/${REPO}.git
        
        # è¿›å…¥ä»“åº“å¹¶æ›´æ–°æ–‡ä»¶
        cd ${REPO}
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        mkdir -p iptv
        
        # æ£€æŸ¥M3Uæ–‡ä»¶æ˜¯å¦ç”Ÿæˆ
        if [ ! -f "../JN950åŸç‰ˆ.m3u" ]; then
          echo "âŒ M3Uæ–‡ä»¶æœªç”Ÿæˆï¼Œè·³è¿‡æ¨é€"
          exit 0
        fi
        
        # å¤åˆ¶æ‰€æœ‰M3Uæ–‡ä»¶
        cp ../*.m3u ./ 2>/dev/null || true
        
        # æ·»åŠ ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶
        git add .
        
        # æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´
        if ! git diff --cached --quiet; then
          git commit -m "è‡ªåŠ¨åŒæ­¥æ–‡ä»¶ ${BEIJING_TIME}"
          git push origin master
          echo "âœ… æ–‡ä»¶å·²åŒæ­¥ï¼"
        else
          echo "âš ï¸ æ²¡æœ‰æ–‡ä»¶å˜æ›´ï¼Œè·³è¿‡æäº¤"
        fi
        
        echo "ğŸ‰ èŠ‚ç›®m3uæ›´æ–°æˆåŠŸï¼"
